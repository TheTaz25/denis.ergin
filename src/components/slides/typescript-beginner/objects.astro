<section>
	<section>
		<h2>Objekte</h2>
	</section>

	<section>
		<p>In TS gibt es 2 Varianten Objekte zu Typisieren. Dabei definieren wir die Form bzw die Eigenschaften (Properties) innerhalb des Objektes.</p>
	</section>

	<section>
		<h3>Interfaces</h3>
	</section>

	<section>
		<p>Mit Interfaces definieren wir Objekte. Dabei können wir uns das <code>interface</code> noch am ehesten wie eine normale JavaScript-Klasse vorstellen, die später durch weitere Interfaces erweitert werden kann.</p>
		<pre class="ts"><code data-trim data-line-numbers is:raw>
			interface Point2D {
				x: number,
				y: number,
			};

			const location: Point2D = {
				x: 5,
				y: 10,
			};
		</code></pre>
	</section>


	<section>
		<p>Ein Interface kann nun mit einem bestehenden Interface "erweitert" (extended) werden.</p>
		<pre class="ts"><code data-trim data-line-numbers is:raw>
			interface Point3D extends Point2D {
				z: number,
			};

			const location: Point3D = {
				x: 5,
				y: 10,
				z: 20,
			};
		</code></pre>
	</section>

	<section>
		<h3>type</h3>
	</section>

	<section>
		<p>Ein <code>type</code> dient ähnlich zum interface dazu, ein Objekt zu definieren, beschränkt sich aber nicht darauf.</p>
		<pre class="ts"><code data-trim data-line-numbers is:raw>
			type Point2D = {
				x: number;
				y: number;
			};

			// Mit dem "&" können wir mehrere types zusammenführen
			type Point3D = {
				z: number;
			} & Point2D;
		</code></pre>
	</section>

	<section>
		<p>Wie gesagt beschränkt sich eine <code>type</code>-Definition nicht nur auf Objekte, wir können zum Beispiel einen String auf bestimmte Werte "restriktieren".</p>
	</section>

	<section>
		<pre class="ts"><code data-trim data-line-numbers is:raw>
			type Animal = "cat" | "dog" | "hamster";

			const pet: Animal = "cat";

			// Mischformen sind auch möglich
			type Falsy = null | undefined | "" | 0 | false;
		</code></pre>
	</section>
</section>
